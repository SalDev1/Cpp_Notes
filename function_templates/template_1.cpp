#include <iostream>
using namespace std;

// Complier is going to take this template and generate a function.
template <typename T> // Function Declaration.
T maximum(T a, T b);

template <typename T>
T multiply(T a, T b);

int main()
{
  // Function Templates ==> Function Templates.
  // To solve the problems of repetition or function overloads
  // we have looked before , we make use of it.
  // Many problems , one solution

  // Real C++ Function generated by the complier == template instance.
  /*
     Our aim over here is to avoid severals overloads of the same function and
     we have one point of control in our code.

      • Function templates are just blueprints. They're not real C++ code
        consumed by the compiler. The compiler generates real C++ code
        by looking at the arguments you call your function template with

      • The real C++ function generated by the compiler is called a template instance

        A template instance will be reused when a similar function call (argument types) is issued.
        No duplicates are generated by the compiler

        auto = auto type deduction.

        Function templates are going to generate function template instances with actual values.

        Template instances won't always do what you want . A good example is when
        you call our maximum function with pointers , DISASTER !

         The arguments passed to a function template must support the operations that are done in the
         body of the function.
  */
  int a{12};
  int b{34};

  double c{12.34};
  double d{45.67};

  string e = "hello";
  string f = "world";

  cout << "max(int) : " << maximum(a, b) << endl;    // int version created
  cout << "max(double) : " << maximum(c, d) << endl; // double version created
  cout << "max(string) : " << maximum(e, f) << endl; // string version created
  cout << multiply(23, 45) << endl;
  cout << multiply(1.2, 0.5) << endl;
  // cout << multiply(e, f) << endl;

  return 0;
}
// This template can consider any datatype and produces the desirable outputs.
// T when calling the function is replaced with data type(int , double , string).
template <typename T> // Function Definiton.
T maximum(T a, T b)
{
  return a > b ? a : b;
}

template <typename T>
T multiply(T a, T b)
{
  return a * b;
}